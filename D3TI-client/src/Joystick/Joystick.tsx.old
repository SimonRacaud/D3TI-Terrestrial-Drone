import React, { useState } from "react";
import { GestureResponderEvent, View } from "react-native";
import * as utils from "./utils";

export interface JoystickUpdateEvent {
  type: "move" | "stop" | "start";
  position: {
    x: number;
    y: number;
  };
  force: number;
  angle: {
    radian: number;
    degree: number;
  };
}

interface IProps {
  onStart?: (e: JoystickUpdateEvent) => void;
  onMove?: (e: JoystickUpdateEvent) => void;
  onStop?: (e: JoystickUpdateEvent) => void;
  radius?: number;
  color?: string;
}

// interface IState {
//   x: number,
//   y: number
// }

// export default class AxisPad extends React.Component<IProps> {

//   constructor(props: IProps) {
//     super(props);
//   }
// }

const AxisPad: React.FC<IProps> = (props) => {
  const { onStart, onMove, onStop, color = "#000000", radius = 150 } = props;

  const wrapperRadius = radius;
  const nippleRadius = wrapperRadius / 3;

  const [x, setX] = useState(wrapperRadius - nippleRadius);
  const [y, setY] = useState(wrapperRadius - nippleRadius);

  const handleTouchMove = (e: GestureResponderEvent) => {
    const fingerX = e.nativeEvent.locationX;
    const fingerY = e.nativeEvent.locationY;

    let coordinates = {
      x: fingerX - nippleRadius,
      y: fingerY - nippleRadius,
    };

    const angle = utils.calcAngle(
      { x: fingerX, y: fingerY },
      { x: wrapperRadius, y: wrapperRadius }
    );

    let dist = utils.calcDistance(
      { x: wrapperRadius, y: wrapperRadius },
      { x: fingerX, y: fingerY }
    );

    const force = dist / (nippleRadius * 2);

    dist = Math.min(dist, wrapperRadius);
    if (dist === wrapperRadius) {
      return;
    }

    setX(coordinates.x);
    setY(coordinates.y);

    /// Position => scope (-1; 1)
    const position = {
      x: (fingerX - wrapperRadius) / wrapperRadius,
      y: (fingerY - wrapperRadius) / wrapperRadius
    }

    onMove &&
      onMove({
        position: position,
        angle: {
          radian: utils.degreesToRadians(angle),
          degree: angle,
        },
        force,
        type: "move",
      });
  };

  const handleTouchEnd = (e: GestureResponderEvent) => {
    setX(wrapperRadius - nippleRadius);
    setY(wrapperRadius - nippleRadius);
    onStop &&
      onStop({
        force: 0,
        position: {
          x: 0,
          y: 0,
        },
        angle: {
          radian: 0,
          degree: 0,
        },
        type: "stop",
      });
  };

  const handleTouchStart = (e: GestureResponderEvent) => {
    onStart &&
      onStart({
        force: 0,
        position: {
          x: 0,
          y: 0,
        },
        angle: {
          radian: 0,
          degree: 0,
        },
        type: "start",
      });
  };

  return (
    <View
      onTouchMove={handleTouchMove}
      onTouchEnd={handleTouchEnd}
      onTouchStart={handleTouchStart}
      style={[
        {
          width: 2 * radius,
          height: 2 * radius,
          backgroundColor: `${color}55`,
          position: "relative"
        },
        {
          transform: [{ rotateX: "180deg" }],
        },
      ]}
    >
      <View
        pointerEvents="none"
        style={[
          {
            height: 2 * nippleRadius,
            width: 2 * nippleRadius,
            borderRadius: nippleRadius,
            backgroundColor: `${color}bb`,
          },
          {
            position: "absolute",
            transform: [
              {
                translateX: x,
              },
              { translateY: y },
            ],
          },
        ]}
      />
    </View>
  );
};

export default AxisPad;
